# 自动化构建

（自动化构建工作流）：源代码　=> 生产代码

提高效率的语法，规范

## NPM Scripts

实现自动化构建最简单的方式

browser-sync: 将本地 html 文件加载到浏览器中

sass: 编译 sass 文件

npm-run-all: 同时跑任务

```
// package.json
"scripts: {
  "build": "sass scss/main.scss css/style.css --watch",
  "serve": "browser-sync . --files \"css/*.css\"",
  "start": "run-p build serve"
}
```

## 常用的自动化构建工具

- Grunt
- Gulp
- FIS

### Grunt 使用

在 `gruntfile.js` 中注册任务

```js
// Grunt 的入口文件
// 用于定义一些需要 Grunt 自动执行的任务

module.exports = (grunt) => {
  grunt.registerTask("foo", () => {
    console.log("hello grunt!!");
  });

  grunt.registerTask("bar", () => {
    console.log("other task!");
  });
};
```

#### 标记任务的失败

同步任务: `return false`

异步任务: `this.async(false)`

#### 加载配置

```js
grunt.initConfig({
  foo: {
    bar: 123,
  },
});

grunt.config(); // 可以拿到配置
```

#### 多目标任务

在 initConfig 处定义 build 参数, 给批量运行使用

```js
```

#### 使用插件

插件命名格式: `grunt-contrib-*`

使用 `clean` 插件删除文件夹/文件

```js
grunt.initConfig({
  clean: {
    temp: "temp/**",
  },
});

grunt.loadNpmTasks("grunt-contrib-clean");
```

常用插件:

grunt-sass: 配合 sass 模块 使用

grunt-babel: 配合 @babel/core @babel/preset-env

## Gulp

### 基本使用

以模块导出来定义任务

所有都是异步任务,要手动调用 done 结束

### 组合使用

series: 串行任务

parallel: 并行任务

### 异步任务调用几种方式

```js
// 执行回调
exports.callback = (done) => {
  console.log("callback~");
  done();
};
// 抛出错误
exports.callback_error = (done) => {
  console.log("callback~");
  done(new Error("task failed!"));
};
```

```js
// promise way
// gulp忽略resolve的值
exports.promise = () => {
  console.log("promise task~");
  return Promise.resolve();
};
// 抛出错误
exports.promise_error = () => {
  console.log("promise task~");
  return Promise.reject(new Error("task failed~"));
};
```

```js
const timeout = (time) => {
  return new Promise((resolve) => {
    setTimeout(resolve, time);
  });
};

// async - await
exports.async = async () => {
  await timeout(1000);
  console.log("async task~");
};
```

### 核心工作原理

读取文件流 -> pipe -> 输出流

中间的管道可以用各式各样的流处理拼接成

### 文件操作 API

src('path/file') : 支持通配符

dest: 输出到目标目录

gulp-clean-css: 压缩 CSS 插件

gulp-rename: 重命名插件

### 案例: 编译使用了模板的网页工程

#### 按照原来的目录结构输出, 指定 src 　函数选项 {base: ''}

```js
src("src/assets/styles/*.scss", { base: "src" }).pipe(dest("dist"));
```

#### 编译 sass

安装 gulp sass 插件

```
yarn add gulp-sass --dev
```

```js
const style = () => {
  return src("src/assets/styles/*.scss", { base: "src" })
    .pipe(sass({ outputStyle: "expanded" }))
    .pipe(dest("dist"));
};
```

会忽略 `_`开头的文件, 指定 `{outputStyle: 'expand'}` 将右括号换行输出(默认在结束行输出)

#### 脚本 编译

安装 gulp babel 插件

```
yarn add gulp-babel --dev
yarn add @babel/core @babel/preset-env --dev # 还要安装babel核心和ES新特性编译环境
```

记得在 babel 中使用`presets`指定要转换的特性预设

```js
const babel = require("gulp-babel");

const script = () => {
  return src("src/assets/scripts/*.js", { base: "src" })
    .pipe(babel({ presets: ["@babel/preset-env"] }))
    .pipe(dest("dist"));
};
```

#### 页面模板编译

使用 gulp swig 作为模板编译插件

```
yarn add gulp-swig --dev
```

swig 可以传入模板变量

```js
const swig = require("gulp-swig");
const data = {};

const page = () => {
  return src("src/*.html").pipe(swig({ data })).pipe(dest("dist"));
};
```

#### 组合任务

使用 parallel 构成并行任务

```js
const compile = parallel(page, style, script);
```

#### 转换图片和字体文件

使用 gulp-imagemin 压缩图片和转移字体文件

```js
const imagemin = require("gulp-imagemin");

const image = () => {
  return src("src/assets/images/**", { base: "src" })
    .pipe(imagemin())
    .pipe(dest("dist"));
};

const font = () => {
  return src("src/assets/fonts/**", { base: "src" })
    .pipe(imagemin())
    .pipe(dest("dist"));
};
```

#### 清除目录

不是 gulp 插件, 是一个 promise 的库

```
yarn add del --dev
```

```js
const clean = () => {
  return del(["dist"]);
};
```

#### 自动加载插件

```
const loadPlugins = require("gulp-load-plugins");

const plugins = loadPlugins(); // 自动加载插件

// 后面的插件全都用 plugins.xxx使用
```
